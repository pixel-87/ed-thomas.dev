---
title: "vibe coding small, purpose-built, personal software"
description: "Making purpose-built software for personal use has become incredibly easy"
pubDate: 2025-12-28
tags: ["vibe coding", "Unix Philosophy"]
featured: true
draft: false
area: "tech"
---

<div class="callout note">
  <div class="callout-heading">Vibe Coding</div>
  <p>
    The use of artificial intelligence prompted by natural language to assist with
    the writing of computer code. - Collins Dictionary
  </p>
</div>

While vibe coding has been incredibly controversial in the tech space, it is inarguably revolutionary.

In this post, I'd like to talk about why vibe coding is incredible for implementing the [Unix philosophy](https://en.wikipedia.org/wiki/Unix_philosophy) in the making of small, purpose-built tools and software for personal use.

<div class="callout note">
<div class="callout-heading">Unix Philosophy</div>
<p>
    Summarised by <a href="https://en.wikipedia.org/wiki/Peter_H._Salus">Peter H. Salus</a>, the philosophy can be broken down into 3 points.
</p>
<ul class="list-dash">
    <li>Write programs that do one thing and do it well.</li>
    <li>Write programs to work together.</li>
    <li>Write programs to handle text streams, because that is a universal interface.</li>
</ul>
</div>

In my opinion, the first point-doing one thing well-is the most relavent concerning vibe coding, seen in how LLMs handle high context scenarios.

LLMs thrive in small problem spaces. Huge codebases or ambiguious, broad goals for the final product often lead to a frustrating experience working against the ai agent. Context becomes bloated, and the agent fixes one bug only to create two more.

By keeping projects (and the context window) small, so that a piece of software only solves one problem, vibe coding does a much better job at implementing what you are imagining.

This lets you build using tech you don't know bypassing the *syntax tax*. You can build a browser extension for a small problem you have without knowing js/ts. Make a personal website without knowing html, make an api using Flask in Python without having touched the library before.

AI allows for hyper-personalised, utility software to be made incredibly easily, there is no barrier to entry on needing to learn specifc tech to solve a specifc problem.

## My Example - A Browser Extension

I frequently do paid surveys on [prolific.com](https://www.prolific.com). These surveys payout in both pounds(Â£) and dollars($).

A small gripe I've had for a while is that I can't easily tell between two surveys which one pays better. Is ten dollars more or less than eight quid? When the values are this close, it's a coin toss trying to do it intuitively.

This is such a small problem with little payoff for solving it, I don't know js/ts, so it wasn't worth reading documentation for a while to build an extension. So, I got copilot to make it for me.

We made a browser extension that fetches the current exchange rates and converts the dollars to pounds in the page. It's a simple extension, but not one I could of easily made myself with my current skills.

The extension only does one job, and it does it well.

While learning ts and how to make extensions is useful, and it would be fun to learn and do it all myself, its just not really a skill worth putting the time into to learn for where I am in my life right now.

## Further examples [Ben Vallack's DIY Software](https://www.youtube.com/BenVallack)

Ben has made some great videos of software built to solve his exact problems for his situation and goals. He's vibe coded a series of different apps to reduce his reliance on cloud subscriptions and to have it do exactly what he wants. 

The idea of having one tool doing one thing well is seen throughout his work.

## Conclusion

LLMs have effectively eliminated the barrier to solving small scope problems well for developers and even non-technical users with the rising popularity of no-code services.

If you have a small, annoying friction in your digital life, you don't need to wait for a company to make a solution, or to spend time learning languages or frameworks, just vibe code it.

Keep the scope and context small, build some Unix-style tools to solve exactly your problem.
